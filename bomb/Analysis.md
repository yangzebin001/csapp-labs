# CSAPP-BOMB lab 分析



## 第一关

首先我们查阅所给的bomb.c文件，发现有6个关卡，每次读一行，然后调用相应的函数进行操作。

了解了大致的流程后，我们开始使用gdb命令进行代码的调试。

调试该可执行文件：

```
gdb bomb
```

然后使用：

```
r
```

表示开始程序，然后发现要我们输入一些参数。

刚开始我们不知道密码是什么，先随便输入一些测试下，发现果然bomb了。

然后查看源文件，发现输入参数后，调用了phase_1函数，所以我们重新开始一次调试，使用：

```
b phase_1
```

到phase_1函数处打个断点。然后使用：

```
disas
```

查看 汇编代码：

### phase_1

```
=> 0x0000000000400ee0 <+0>:	sub    $0x8,%rsp
   0x0000000000400ee4 <+4>:	mov    $0x402400,%esi  //0x402400指向的内存地址内容为：Border relations with Canada have never been better.
   0x0000000000400ee9 <+9>:	callq  0x401338 <strings_not_equal>
   0x0000000000400eee <+14>:	test   %eax,%eax
   0x0000000000400ef0 <+16>:	je     0x400ef7 <phase_1+23>
   0x0000000000400ef2 <+18>:	callq  0x40143a <explode_bomb>
   0x0000000000400ef7 <+23>:	add    $0x8,%rsp
   0x0000000000400efb <+27>:	retq 
```

可以使用：

```
ni
```

执行一条汇编指令。

通过使用：

```
p $eax
```

查看eax寄存器中的内容（其他寄存器同理）。

看该函数汇编代码前三句，有一条mov，和一条callq指令。mov指令把一个地址内容传送给了esi寄存器。

我们用x /s 内存地址 将0x402400指向的内容打印出来：

```
(gdb) x /s 0x402400
0x402400:	"Border relations with Canada have never been better."
```

大致翻译下上面的汇编内容就是：将读入的字符串和0x402400指向的字符串比较，不相同就调用explode_bomb函数。否则该函数结束。

我们重新退出，重新进入后输入上述字符串。

```
Phase 1 defused. How about the next one?
```

恭喜通过了第一关。

## 第二关

接下来我们进入第二关，和之前一样，在phase_2处打个断点

```
b phase_2
```

查看汇编代码：

```
disas
```

### phase_2

```
Dump of assembler code for function phase_2:
=> 0x0000000000400efc <+0>:	push   %rbp
   0x0000000000400efd <+1>:	push   %rbx
   0x0000000000400efe <+2>:	sub    $0x28,%rsp
   0x0000000000400f02 <+6>:	mov    %rsp,%rsi
   0x0000000000400f05 <+9>:	callq  0x40145c <read_six_numbers> //调用读取六个数字函数
   0x0000000000400f0a <+14>:	cmpl   $0x1,(%rsp)  //将%rsp寄存器中地址指向的值和1比较
   0x0000000000400f0e <+18>:	je     0x400f30 <phase_2+52> //相等则跳转到(+52)
   0x0000000000400f10 <+20>:	callq  0x40143a <explode_bomb> //调用explode_bomb函数，即程序结束。
   0x0000000000400f15 <+25>:	jmp    0x400f30 <phase_2+52> //跳转到(+52)
   0x0000000000400f17 <+27>:	mov    -0x4(%rbx),%eax  //将%eax中的内容传送到rbx之前一个4个字节。
   0x0000000000400f1a <+30>:	add    %eax,%eax  //%eax * 2
   0x0000000000400f1c <+32>:	cmp    %eax,(%rbx) //%eax 与(%rbx) 值比较，这里(%rbx)就是输入的数字的地址。第一个和1作比较(+14)，其余的每次增长0x4(+41)
   0x0000000000400f1e <+34>:	je     0x400f25 <phase_2+41> //%eax和输入的数字作比较
   0x0000000000400f20 <+36>:	callq  0x40143a <explode_bomb>
   0x0000000000400f25 <+41>:	add    $0x4,%rbx //%rbx增加4个字节，即指向下一个数字
   0x0000000000400f29 <+45>:	cmp    %rbp,%rbx //和结束地址比较
   0x0000000000400f2c <+48>:	jne    0x400f17 <phase_2+27>
   0x0000000000400f2e <+50>:	jmp    0x400f3c <phase_2+64>
   0x0000000000400f30 <+52>:	lea    0x4(%rsp),%rbx  //将栈指针后一个字节的地址 赋值给%rbx，这里是开始地址。
   0x0000000000400f35 <+57>:	lea    0x18(%rsp),%rbp //配合(+45) 表示结束地址，正常退出
   0x0000000000400f3a <+62>:	jmp    0x400f17 <phase_2+27> //跳转到(+27)
   0x0000000000400f3c <+64>:	add    $0x28,%rsp  //回收栈帧
   0x0000000000400f40 <+68>:	pop    %rbx
   0x0000000000400f41 <+69>:	pop    %rbp
   0x0000000000400f42 <+70>:	retq   //函数返回调用
End of assembler dump.

```

开始发现调用了read_six_numbers，所以应该是要我们读入6个数字。

然后通过反复的 ni、p和x 命令，搞清楚每条汇编指令的含义，基本上就是第一个数要为1，然后每次*2。也就是

```
1 2 4 8 16 32
```

重新输入这几个数字，

```
That's number 2.  Keep going!
```

恭喜通过第二关。

## 第三关

### phase_3

(gdb) x /s $rsi
0x4025cf:	"%d %d"



```
Dump of assembler code for function phase_3:
   0x0000000000400f43 <+0>:	sub    $0x18,%rsp
   0x0000000000400f47 <+4>:	lea    0xc(%rsp),%rcx
   0x0000000000400f4c <+9>:	lea    0x8(%rsp),%rdx
   0x0000000000400f51 <+14>:	mov    $0x4025cf,%esi
   0x0000000000400f56 <+19>:	mov    $0x0,%eax
   0x0000000000400f5b <+24>:	callq  0x400bf0 <__isoc99_sscanf@plt> //$rsi: "%d %d"
=> 0x0000000000400f60 <+29>:	cmp    $0x1,%eax 
   0x0000000000400f63 <+32>:	jg     0x400f6a <phase_3+39> //大于一个参数，跳到(+39)
   0x0000000000400f65 <+34>:	callq  0x40143a <explode_bomb>
   0x0000000000400f6a <+39>:	cmpl   $0x7,0x8(%rsp) 
   0x0000000000400f6f <+44>:	ja     0x400fad <phase_3+106>  // 第一个参数大于7，结束
   0x0000000000400f71 <+46>:	mov    0x8(%rsp),%eax  //第一个参数保存到$eax中
   0x0000000000400f75 <+50>:	jmpq   *0x402470(,%rax,8) //跳到(+64)
   0x0000000000400f7c <+57>:	mov    $0xcf,%eax  //207   //case : 0
   0x0000000000400f81 <+62>:	jmp    0x400fbe <phase_3+123>
   0x0000000000400f83 <+64>:	mov    $0x2c3,%eax   //707   //case : 2
   0x0000000000400f88 <+69>:	jmp    0x400fbe <phase_3+123>
   0x0000000000400f8a <+71>:	mov    $0x100,%eax  //256   //case : 3
   0x0000000000400f8f <+76>:	jmp    0x400fbe <phase_3+123>
   0x0000000000400f91 <+78>:	mov    $0x185,%eax  //389   //case : 4
   0x0000000000400f96 <+83>:	jmp    0x400fbe <phase_3+123>
   0x0000000000400f98 <+85>:	mov    $0xce,%eax  //206   //case : 5
   0x0000000000400f9d <+90>:	jmp    0x400fbe <phase_3+123>
   0x0000000000400f9f <+92>:	mov    $0x2aa,%eax  //682   //case : 6
   0x0000000000400fa4 <+97>:	jmp    0x400fbe <phase_3+123>
   0x0000000000400fa6 <+99>:	mov    $0x147,%eax  //327   //case : 7
   0x0000000000400fab <+104>:	jmp    0x400fbe <phase_3+123>
   0x0000000000400fad <+106>:	callq  0x40143a <explode_bomb>
   0x0000000000400fb2 <+111>:	mov    $0x0,%eax  //0 
   0x0000000000400fb7 <+116>:	jmp    0x400fbe <phase_3+123>
   0x0000000000400fb9 <+118>:	mov    $0x137,%eax  //311 //case : 1
   0x0000000000400fbe <+123>:	cmp    0xc(%rsp),%eax  //比较第二个 
   0x0000000000400fc2 <+127>:	je     0x400fc9 <phase_3+134>
   0x0000000000400fc4 <+129>:	callq  0x40143a <explode_bomb>
   0x0000000000400fc9 <+134>:	add    $0x18,%rsp
   0x0000000000400fcd <+138>:	retq 
```



### phase_4

```
=> 0x000000000040100c <+0>:	sub    $0x18,%rsp
   0x0000000000401010 <+4>:	lea    0xc(%rsp),%rcx
   0x0000000000401015 <+9>:	lea    0x8(%rsp),%rdx
   0x000000000040101a <+14>:	mov    $0x4025cf,%esi
   0x000000000040101f <+19>:	mov    $0x0,%eax
   0x0000000000401024 <+24>:	callq  0x400bf0 <__isoc99_sscanf@plt>
   0x0000000000401029 <+29>:	cmp    $0x2,%eax  //是否是两个参数
   0x000000000040102c <+32>:	jne    0x401035 <phase_4+41> 
   0x000000000040102e <+34>:	cmpl   $0xe,0x8(%rsp)  //15 和 第一个参数比较
   0x0000000000401033 <+39>:	jbe    0x40103a <phase_4+46>  //小于等于
   0x0000000000401035 <+41>:	callq  0x40143a <explode_bomb>
   0x000000000040103a <+46>:	mov    $0xe,%edx  //14 to $edx
   0x000000000040103f <+51>:	mov    $0x0,%esi  //0 to $esi
   0x0000000000401044 <+56>:	mov    0x8(%rsp),%edi  //第一个参数 to $edi
   0x0000000000401048 <+60>:	callq  0x400fce <func4> 
   0x000000000040104d <+65>:	test   %eax,%eax  //test eax == 0
   0x000000000040104f <+67>:	jne    0x401058 <phase_4+76>  //eax != 0 爆炸
   0x0000000000401051 <+69>:	cmpl   $0x0,0xc(%rsp) //0和第二个参数
   0x0000000000401056 <+74>:	je     0x40105d <phase_4+81> // 0 == 第二个参数
   0x0000000000401058 <+76>:	callq  0x40143a <explode_bomb>
   0x000000000040105d <+81>:	add    $0x18,%rsp
   0x0000000000401061 <+85>:	retq 
```

### func4

```
$edx = 15 
$esi = 0
$edi = 第一个参数
0000000000400fce <func4>:
=> 0x0000000000400fce <+0>:	sub    $0x8,%rsp
   0x0000000000400fd2 <+4>:	mov    %edx,%eax //$eax = 14
   0x0000000000400fd4 <+6>:	sub    %esi,%eax //$eax-0 = 14
   0x0000000000400fd6 <+8>:	mov    %eax,%ecx //$ecx = 14
   0x0000000000400fd8 <+10>:	shr    $0x1f,%ecx //$ecx>>31  获得符号位
   0x0000000000400fdb <+13>:	add    %ecx,%eax // $eax = 14 + 0 = 14
   0x0000000000400fdd <+15>:	sar    %eax // $eax >> 1 = 7
   0x0000000000400fdf <+17>:	lea    (%rax,%rsi,1),%ecx 
   0x0000000000400fe2 <+20>:	cmp    %edi,%ecx 
   0x0000000000400fe4 <+22>:	jle    0x400ff2 <func4+36>  //$ecx 小于等于 $edi
   0x0000000000400fe6 <+24>:	lea    -0x1(%rcx),%edx //$ecx = $rcx -1
   0x0000000000400fe9 <+27>:	callq  0x400fce <func4> //递归调用
   0x0000000000400fee <+32>:	add    %eax,%eax // $eax += $eax
   0x0000000000400ff0 <+34>:	jmp    0x401007 <func4+57>
   0x0000000000400ff2 <+36>:	mov    $0x0,%eax  //$eax = 0
   0x0000000000400ff7 <+41>:	cmp    %edi,%ecx 
   0x0000000000400ff9 <+43>:	jge    0x401007 <func4+57>  //$ecx 大于等于 $edi  完成函数调用
   0x0000000000400ffb <+45>:	lea    0x1(%rcx),%esi   //$esi = $rcx+1
   0x0000000000400ffe <+48>:	callq  0x400fce <func4>
   0x0000000000401003 <+53>:	lea    0x1(%rax,%rax,1),%eax //$eax = $rax*2+1
   0x0000000000401007 <+57>:	add    $0x8,%rsp
   0x000000000040100b <+61>:	retq 
```

```
a = $edx = 14
b = $esi  = 0
c = $edi = 1 (给定的第一个参数)
d = $eax = a
d -= b
e = $ecx = d >> 31 获得d的符号位
d += e  //14
d >>= 1 //7
e = d + b // 7
if(e <= c){
	d = 0
	if(e >= c){
		return;
	}else{
		a = e - 1
	}
}
func4
a  += a + 1
```





### phase_5

```
Dump of assembler code for function phase_5:
=> 0x0000000000401062 <+0>:	push   %rbx
   0x0000000000401063 <+1>:	sub    $0x20,%rsp
   0x0000000000401067 <+5>:	mov    %rdi,%rbx
   0x000000000040106a <+8>:	mov    %fs:0x28,%rax
   0x0000000000401073 <+17>:	mov    %rax,0x18(%rsp) 
   0x0000000000401078 <+22>:	xor    %eax,%eax
   0x000000000040107a <+24>:	callq  0x40131b <string_length>
   0x000000000040107f <+29>:	cmp    $0x6,%eax  //字符串长度为6
   0x0000000000401082 <+32>:	je     0x4010d2 <phase_5+112>
   0x0000000000401084 <+34>:	callq  0x40143a <explode_bomb>
   0x0000000000401089 <+39>:	jmp    0x4010d2 <phase_5+112>
   0x000000000040108b <+41>:	movzbl (%rbx,%rax,1),%ecx  //
   0x000000000040108f <+45>:	mov    %cl,(%rsp) 
   0x0000000000401092 <+48>:	mov    (%rsp),%rdx
   0x0000000000401096 <+52>:	and    $0xf,%edx  //取低四位
   0x0000000000401099 <+55>:	movzbl 0x4024b0(%rdx),%edx  //97 "maduiersnfotvbyl"
   0x00000000004010a0 <+62>:	mov    %dl,0x10(%rsp,%rax,1) 
   0x00000000004010a4 <+66>:	add    $0x1,%rax  
   0x00000000004010a8 <+70>:	cmp    $0x6,%rax 
   0x00000000004010ac <+74>:	jne    0x40108b <phase_5+41>
   0x00000000004010ae <+76>:	movb   $0x0,0x16(%rsp)  //$rax = 6
   0x00000000004010b3 <+81>:	mov    $0x40245e,%esi  //flyers f:9 l:15 y:14 e:5 r:6 s:7 "9?>567"
   0x00000000004010b8 <+86>:	lea    0x10(%rsp),%rdi  //读入的字符串 
   0x00000000004010bd <+91>:	callq  0x401338 <strings_not_equal> //比较字符串是否相等
   0x00000000004010c2 <+96>:	test   %eax,%eax
   0x00000000004010c4 <+98>:	je     0x4010d9 <phase_5+119>
   0x00000000004010c6 <+100>:	callq  0x40143a <explode_bomb>
   0x00000000004010cb <+105>:	nopl   0x0(%rax,%rax,1)
   0x00000000004010d0 <+110>:	jmp    0x4010d9 <phase_5+119>
   0x00000000004010d2 <+112>:	mov    $0x0,%eax
   0x00000000004010d7 <+117>:	jmp    0x40108b <phase_5+41>
   0x00000000004010d9 <+119>:	mov    0x18(%rsp),%rax
   0x00000000004010de <+124>:	xor    %fs:0x28,%rax
   0x00000000004010e7 <+133>:	je     0x4010ee <phase_5+140>
   0x00000000004010e9 <+135>:	callq  0x400b30 <__stack_chk_fail@plt>
   0x00000000004010ee <+140>:	add    $0x20,%rsp
   0x00000000004010f2 <+144>:	pop    %rbx
   0x00000000004010f3 <+145>:	retq   
End of assembler dump.

将读入的字符串的第4位得到的数字下标到"maduiersnfotvbyl"中转换得到最终的字符串与"flyers"比较。
```



### phase_6

```
=> 0x00000000004010f4 <+0>:	push   %r14
   0x00000000004010f6 <+2>:	push   %r13
   0x00000000004010f8 <+4>:	push   %r12
   0x00000000004010fa <+6>:	push   %rbp
   0x00000000004010fb <+7>:	push   %rbx
   0x00000000004010fc <+8>:	sub    $0x50,%rsp
   0x0000000000401100 <+12>:	mov    %rsp,%r13
   0x0000000000401103 <+15>:	mov    %rsp,%rsi
   0x0000000000401106 <+18>:	callq  0x40145c <read_six_numbers>
   0x000000000040110b <+23>:	mov    %rsp,%r14
   0x000000000040110e <+26>:	mov    $0x0,%r12d
   0x0000000000401114 <+32>:	mov    %r13,%rbp  //外层循环开始
   0x0000000000401117 <+35>:	mov    0x0(%r13),%eax
   0x000000000040111b <+39>:	sub    $0x1,%eax
   0x000000000040111e <+42>:	cmp    $0x5,%eax
   0x0000000000401121 <+45>:	jbe    0x401128 <phase_6+52> //参数低于(unsigned)等于6
   0x0000000000401123 <+47>:	callq  0x40143a <explode_bomb>
   0x0000000000401128 <+52>:	add    $0x1,%r12d  //0 --> 1
   0x000000000040112c <+56>:	cmp    $0x6,%r12d  //外层循环到6结束
   0x0000000000401130 <+60>:	je     0x401153 <phase_6+95> //到六跳转
   0x0000000000401132 <+62>:	mov    %r12d,%ebx
   0x0000000000401135 <+65>:	movslq %ebx,%rax  //内层循环开始
   0x0000000000401138 <+68>:	mov    (%rsp,%rax,4),%eax //从下标1开始取元素
   0x000000000040113b <+71>:	cmp    %eax,0x0(%rbp)  //与第一个元素比较，必须不等于
   0x000000000040113e <+74>:	jne    0x401145 <phase_6+81>
   0x0000000000401140 <+76>:	callq  0x40143a <explode_bomb>
   0x0000000000401145 <+81>:	add    $0x1,%ebx
   0x0000000000401148 <+84>:	cmp    $0x5,%ebx  //内层循环结束
   0x000000000040114b <+87>:	jle    0x401135 <phase_6+65> //小于等于5继续取栈顶元素
   0x000000000040114d <+89>:	add    $0x4,%r13  //指向第二个数
   0x0000000000401151 <+93>:	jmp    0x401114 <phase_6+32> //每个元素都要小于等于6
   0x0000000000401153 <+95>:	lea    0x18(%rsp),%rsi
   0x0000000000401158 <+100>:	mov    %r14,%rax  //第六个参数
   0x000000000040115b <+103>:	mov    $0x7,%ecx  
   0x0000000000401160 <+108>:	mov    %ecx,%edx 
   0x0000000000401162 <+110>:	sub    (%rax),%edx 
   0x0000000000401164 <+112>:	mov    %edx,(%rax) //(%rax) = 7-(%rax)
   0x0000000000401166 <+114>:	add    $0x4,%rax  下一个数
   0x000000000040116a <+118>:	cmp    %rsi,%rax  //与界限值比较
   0x000000000040116d <+121>:	jne    0x401160 <phase_6+108>
   0x000000000040116f <+123>:	mov    $0x0,%esi
   0x0000000000401174 <+128>:	jmp    0x401197 <phase_6+163>
   0x0000000000401176 <+130>:	mov    0x8(%rdx),%rdx //332 168 924 691 477 443
   0x000000000040117a <+134>:	add    $0x1,%eax
   0x000000000040117d <+137>:	cmp    %ecx,%eax
   0x000000000040117f <+139>:	jne    0x401176 <phase_6+130>
   0x0000000000401181 <+141>:	jmp    0x401188 <phase_6+148>
   0x0000000000401183 <+143>:	mov    $0x6032d0,%edx //332 168 924 691 477 443
   0x0000000000401188 <+148>:	mov    %rdx,0x20(%rsp,%rsi,2) 
   0x000000000040118d <+153>:	add    $0x4,%rsi
   0x0000000000401191 <+157>:	cmp    $0x18,%rsi
   0x0000000000401195 <+161>:	je     0x4011ab <phase_6+183> //将这几个数移动到数组中
   0x0000000000401197 <+163>:	mov    (%rsp,%rsi,1),%ecx //从前往后取一个数
   0x000000000040119a <+166>:	cmp    $0x1,%ecx  //取对应下标的数字
   0x000000000040119d <+169>:	jle    0x401183 <phase_6+143> //小于等于1 取出332
   0x000000000040119f <+171>:	mov    $0x1,%eax
   0x00000000004011a4 <+176>:	mov    $0x6032d0,%edx
   0x00000000004011a9 <+181>:	jmp    0x401176 <phase_6+130>
   0x00000000004011ab <+183>:	mov    0x20(%rsp),%rbx  //443
   0x00000000004011b0 <+188>:	lea    0x28(%rsp),%rax  //447
   0x00000000004011b5 <+193>:	lea    0x50(%rsp),%rsi
   0x00000000004011ba <+198>:	mov    %rbx,%rcx
   0x00000000004011bd <+201>:	mov    (%rax),%rdx
   0x00000000004011c0 <+204>:	mov    %rdx,0x8(%rcx)
   0x00000000004011c4 <+208>:	add    $0x8,%rax
   0x00000000004011c8 <+212>:	cmp    %rsi,%rax
   0x00000000004011cb <+215>:	je     0x4011d2 <phase_6+222>
   0x00000000004011cd <+217>:	mov    %rdx,%rcx
   0x00000000004011d0 <+220>:	jmp    0x4011bd <phase_6+201>
   0x00000000004011d2 <+222>:	movq   $0x0,0x8(%rdx)
   0x00000000004011da <+230>:	mov    $0x5,%ebp
   0x00000000004011df <+235>:	mov    0x8(%rbx),%rax
   0x00000000004011e3 <+239>:	mov    (%rax),%eax
   0x00000000004011e5 <+241>:	cmp    %eax,(%rbx)
   0x00000000004011e7 <+243>:	jge    0x4011ee <phase_6+250>
   0x00000000004011e9 <+245>:	callq  0x40143a <explode_bomb>
   0x00000000004011ee <+250>:	mov    0x8(%rbx),%rbx
   0x00000000004011f2 <+254>:	sub    $0x1,%ebp
   0x00000000004011f5 <+257>:	jne    0x4011df <phase_6+235>
   0x00000000004011f7 <+259>:	add    $0x50,%rsp
   0x00000000004011fb <+263>:	pop    %rbx
   0x00000000004011fc <+264>:	pop    %rbp
   0x00000000004011fd <+265>:	pop    %r12
   0x00000000004011ff <+267>:	pop    %r13
   0x0000000000401201 <+269>:	pop    %r14
   0x0000000000401203 <+271>:	retq
```



#### 大致流程

```

for(int i = 1; i <= 5; i++){ i=$r12d
	a[i]-1 <= 5
	for(int j = i; j <= 5; j++){ j = $ebx
		a[j] != a[i];
	}
}
int b = 7;
for(int i = 0; i <= 5; i++){
	a[i] = 7-a[i];
}

//332 168 924 691 477 443
//443 477 691 924 168 332
按从小到大排序
3 4 5 6 1 2
4 3 2 1 6 5

```





### phase_defused

```
=> 0x00000000004015c4 <+0>:	sub    $0x78,%rsp
   0x00000000004015c8 <+4>:	mov    %fs:0x28,%rax
   0x00000000004015d1 <+13>:	mov    %rax,0x68(%rsp)
   0x00000000004015d6 <+18>:	xor    %eax,%eax
   0x00000000004015d8 <+20>:	cmpl   $0x6,0x202181(%rip)    //对应最后一关
   0x00000000004015df <+27>:	jne    0x40163f <phase_defused+123>
   0x00000000004015e1 <+29>:	lea    0x10(%rsp),%r8
   0x00000000004015e6 <+34>:	lea    0xc(%rsp),%rcx
   0x00000000004015eb <+39>:	lea    0x8(%rsp),%rdx
   0x00000000004015f0 <+44>:	mov    $0x402619,%esi //"%d %d %s"
   0x00000000004015f5 <+49>:	mov    $0x603870,%edi //对应第四关的输入 原先是读两个数，现在是读两个数加一个字符串
   0x00000000004015fa <+54>:	callq  0x400bf0 <__isoc99_sscanf@plt>
   0x00000000004015ff <+59>:	cmp    $0x3,%eax
   0x0000000000401602 <+62>:	jne    0x401635 <phase_defused+113>
   0x0000000000401604 <+64>:	mov    $0x402622,%esi
   0x0000000000401609 <+69>:	lea    0x10(%rsp),%rdi
   0x000000000040160e <+74>:	callq  0x401338 <strings_not_equal>
   0x0000000000401613 <+79>:	test   %eax,%eax
   0x0000000000401615 <+81>:	jne    0x401635 <phase_defused+113>
   0x0000000000401617 <+83>:	mov    $0x4024f8,%edi
   0x000000000040161c <+88>:	callq  0x400b10 <puts@plt>
   0x0000000000401621 <+93>:	mov    $0x402520,%edi
   0x0000000000401626 <+98>:	callq  0x400b10 <puts@plt>
   0x000000000040162b <+103>:	mov    $0x0,%eax
   0x0000000000401630 <+108>:	callq  0x401242 <secret_phase>  //进入secret_phase
   0x0000000000401635 <+113>:	mov    $0x402558,%edi
   0x000000000040163a <+118>:	callq  0x400b10 <puts@plt>
   0x000000000040163f <+123>:	mov    0x68(%rsp),%rax
   0x0000000000401644 <+128>:	xor    %fs:0x28,%rax
   0x000000000040164d <+137>:	je     0x401654 <phase_defused+144>
   0x000000000040164f <+139>:	callq  0x400b30 <__stack_chk_fail@plt>
   0x0000000000401654 <+144>:	add    $0x78,%rsp
   0x0000000000401658 <+148>:	retq
```

### secret_phase

```
=> 0x0000000000401242 <+0>:	push   %rbx
   0x0000000000401243 <+1>:	callq  0x40149e <read_line>
   0x0000000000401248 <+6>:	mov    $0xa,%edx
   0x000000000040124d <+11>:	mov    $0x0,%esi
   0x0000000000401252 <+16>:	mov    %rax,%rdi
   0x0000000000401255 <+19>:	callq  0x400bd0 <strtol@plt>
   0x000000000040125a <+24>:	mov    %rax,%rbx
   0x000000000040125d <+27>:	lea    -0x1(%rax),%eax //x--
   0x0000000000401260 <+30>:	cmp    $0x3e8,%eax
   0x0000000000401265 <+35>:	jbe    0x40126c <secret_phase+42>
   0x0000000000401267 <+37>:	callq  0x40143a <explode_bomb> //必须小于等于1000
   0x000000000040126c <+42>:	mov    %ebx,%esi //读入的数
   0x000000000040126e <+44>:	mov    $0x6030f0,%edi //"$"
   0x0000000000401273 <+49>:	callq  0x401204 <fun7> //进入fun7
   0x0000000000401278 <+54>:	cmp    $0x2,%eax //必须返回2
   0x000000000040127b <+57>:	je     0x401282 <secret_phase+64>
   0x000000000040127d <+59>:	callq  0x40143a <explode_bomb>
   0x0000000000401282 <+64>:	mov    $0x402438,%edi
   0x0000000000401287 <+69>:	callq  0x400b10 <puts@plt>
   0x000000000040128c <+74>:	callq  0x4015c4 <phase_defused>
   0x0000000000401291 <+79>:	pop    %rbx
   0x0000000000401292 <+80>:	retq 
```

### fun7

```
=> 0x0000000000401204 <+0>:	sub    $0x8,%rsp
   0x0000000000401208 <+4>:	test   %rdi,%rdi //等于0
   0x000000000040120b <+7>:	je     0x401238 <fun7+52>
   0x000000000040120d <+9>:	mov    (%rdi),%edx //'$' = 36 '2'=50
   0x000000000040120f <+11>:	cmp    %esi,%edx 
   0x0000000000401211 <+13>:	jle    0x401220 <fun7+28>
   0x0000000000401213 <+15>:	mov    0x8(%rdi),%rdi
   0x0000000000401217 <+19>:	callq  0x401204 <fun7>
   0x000000000040121c <+24>:	add    %eax,%eax
   0x000000000040121e <+26>:	jmp    0x40123d <fun7+57>
   0x0000000000401220 <+28>:	mov    $0x0,%eax
   0x0000000000401225 <+33>:	cmp    %esi,%edx  
   0x0000000000401227 <+35>:	je     0x40123d <fun7+57> //要读入的元素和$edx相等
   0x0000000000401229 <+37>:	mov    0x10(%rdi),%rdi //找下个元素
   0x000000000040122d <+41>:	callq  0x401204 <fun7>
   0x0000000000401232 <+46>:	lea    0x1(%rax,%rax,1),%eax //a = 2*a+1
   0x0000000000401236 <+50>:	jmp    0x40123d <fun7+57>
   0x0000000000401238 <+52>:	mov    $0xffffffff,%eax
   0x000000000040123d <+57>:	add    $0x8,%rsp
   0x0000000000401241 <+61>:	retq 
```

#### 大致流程

```

if(di == 0) reutrn 0xffffffff;
dx = di
if(dx <= in){ //第二次的fun7
	ax = 0;
	if(in == dx){ //第三次的fun7
		return ax;
	}else{  //第二次的fun7
		di + 两个偏移;
		fun7();  //第三次的入口
		ax = ax*2+1;
	}
}else{ //第一次进入fun7
	di + 一个偏移;
	fun7(); //第二次的入口
	ax *= 2;
	reutrn;
}


当前di+0偏移 = 36
当前di+1偏移 = 8
当前di+2偏移 = 22
因为要让ax为2， 所以先让
第一次递归di > in, di + 一个偏移;
第二次递归di < in, di + 二个偏移;
第三次递归di == in。


```

